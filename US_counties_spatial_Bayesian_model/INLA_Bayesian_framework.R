## ---------------------------
##
## Script name: INLA_Bayesian_framework
##
## Purpose of script: Run spatial-temporal Bayesian inference on COVID-19 data using environmental and demographic covariates
##
## Authors: Piotr Morawiecki, Laura Oporto, Dan Burrows, Tina Zhou
##
## Date Created: 2020-06-03
##
## Copyright (c) Piotr Morawiecki, 2020
## Email: pwm27@bath.ac.uk
##
## ---------------------------
##
## Notes:
##   
##   The code allows to estimate posteriors distributions of choosen set of model parameters using INLA
##   (INtegrated Laplace Approximaton) package. This packeage computes posterior distribution by approximated
##   numerical integration instead of using MCMC to generate sample from the prosterior distribution,
##   which reduces computation time.
##   There are three basic models to choose from, but it is easy to implement other models as well.
##   In the end of the code the 95% confidence interavals for values of each parameter are plotted for comparison.
##   
## ---------------------------

# Load/install the following packages:
# INLA     required for nb2INLA, inla.read.graph, inla

if("INLA" %in% rownames(installed.packages())==FALSE){install.packages("INLA"); require(INLA)}else{require(INLA)}

# Read the county_data (demographic/economic data and average pollution data) and daily_data (COVID-19 cases and deaths, and daily air quality data)
# which are generated by US_county_datasets_preprocessing.R script.

county_data <- read.csv("county_data.csv")
daily_data <- read.csv("daily_data.csv")

# Merge the data to provide input dataset for INLA

INLA_data <- merge(daily_data, county_data)

# There are two possible COVID-19 descriptors - cases and deaths. To use deaths data set use_deaths to TRUE. To use cases data set deaths to FALSE.
# There are more days with confirmed cases data, but these data are biased # as the number of COVID tests may vary.
# Less data with deaths are available, but it is more reliable.

use_deaths <- TRUE

# To normalize covariates set normalize_variables to TRUE. The normalisation allows the comparisons between the fitted parameters.

normalize_variables <- TRUE

# Vector <covariates> should include the covariates that are used by INLA model. Only rows with full set of data will be used.
# Covariates to choose from are:
# 7  - daily Air Quality Index
# 12 - annual Air Quality Index
# 13 - SO2 average concentration
# 14 - O3 average concentration                
# 15 - PM2.5 average concentration
# 16 - PM10 average concentration
# 17 - NO2 average concentration
# 18 - NO average concentration
# 19 - NOx average concentration
# 20 - CO average concentration
# 21 - income per capita
# 22 - hospital expenditure
# 23 - health expenditure
# 24 - population density

# Formula should include the model for the logarithm of infection rate.
# It is modelled as linear combination of county's population and environmental descriptors. f(id) represents spatial random effects,
# f(day) represents temporal random effects and f(rowId) represents the remaining random effects.

# There I three models that were used to obtained data from the code documentation on GitHub:
# Model 1 describes the impact of average Air Quality Index.
# Model 2 describes the impact of each pollutant separately.
# Model 3 compares the impact of average Air Quality Index (for 2019) to the impact of the current Air Quality Index.

model <- 2

if (model==1) {
  covariates <- c(12, 21, 22, 23, 24)
  formula <- new_cases ~ annual_AQI + incomePerCapita + hospitalExpenditure + healthExpenditure + density +
    f(id, model = "iid") +  f(day, model = "ar1") + f(rowId, model = "iid")
}

if (model==2) {
  covariates <- c(13, 14, 15, 16, 17, 20, 21, 22, 23, 24)
  formula <- new_cases ~ SO2 + O3 + PM2.5 + PM10 + NO2 + CO + incomePerCapita + hospitalExpenditure + healthExpenditure + density +
    f(id, model = "iid") +  f(day, model = "ar1") + f(rowId, model = "iid")
}

if (model==3) {
  covariates <- c(7, 12, 21, 22, 23, 24)
  formula <- new_cases ~ annual_AQI + daily_AQI + incomePerCapita + hospitalExpenditure + healthExpenditure + density +
    f(id, model = "iid") +  f(day, model = "ar1") + f(rowId, model = "iid")
}

# The appropriate columns are selected for the INLA.

if (use_deaths) {
  # If deaths are chosen only the days before which at least (deathsTreshold) deaths were recorded will be used.
  # As in the original dataset the total number of deaths very occassionally decreases these cases are excluded.
  print("Infection rate is estimated based on number of deaths.")
  deathsTreshold <- 1
  INLA_data <- INLA_data[INLA_data$previous_deaths>=deathsTreshold & INLA_data$new_deaths>=0, ]
  variables <- c(3, 4)
} else {
  # If cases are chosen only the days before which at least (casesTreshold) cases were recorded will be used.
  # As in the original dataset the total number of cases very occassionally decreases these cases are excluded.
  print("Infection rate is estimated based on number of confirmed cases.")
  casesTreshold <- 10
  INLA_data <- INLA_data[INLA_data$previous_cases>=casesTreshold & INLA_data$new_cases>=0, ]
  variables <- c(5, 6)
}

# The INLA_data data frame size is reduced by removing unused columns.

INLA_data <- INLA_data[, c(1, 2, variables, covariates)]
colnames(INLA_data)[c(3, 4)] <- c("previous_cases", "new_cases")

# The data with incomplete set of covariates (for example containing NA values) are removed.

INLA_data <- INLA_data[apply(INLA_data, 1, function(x) sum(!is.finite(x))==0),]

# All covariates are normalised. After normalisation their mean is 0 and standard deviation is 1.

if (normalize_variables) {
  print("Covariates are normalised.")
  for (i in 5:ncol(INLA_data)) {
    INLA_data[,i] <- (INLA_data[,i] - mean(INLA_data[,i])) / sd(INLA_data[,i])
  }
} else {
  print("Covariates are not normalised.")
}

# A unique id is assigned to each row to represent the remaining random effects in INLA model

INLA_data$rowId <- 1:nrow(INLA_data)

# The INLA is performed to obtain posterior distribution of model parameters. The model used is described in GitHub repository.

print(paste("The INLA data set consist of", nrow(INLA_data), "records"))
print("INLA has started.")

res <- inla(formula,
            family = "poisson", data = INLA_data, E = previous_cases,
            control.predictor = list(compute = TRUE),
            control.inla = list(int.strategy = "eb")
            )

print("INLA has finished.")

# Summary fixed allows to check confidence intervals for each of linear fitted parameters.

res$summary.fixed

# Here the 95% confidence intervals for each parameter (except for the intercept) are plotted.
# Boxes top and bottom boundary represents 97.5% quantile and 0.025% quantile respectively.
# The horizontal bar inside the rectangle represents the median. Bars with negative median are red,
# while bars with positive median are green.

fixed_parameters <- res$summary.fixed
fixed_parameters <- fixed_parameters[-1,]

x    <- 1:nrow(fixed_parameters)
High <- fixed_parameters$`0.975quant`
Mid  <- fixed_parameters$`0.5quant`
Low  <- fixed_parameters$`0.025quant`
color  <- rep("red", length(x))
color[Mid>0]  <- "green" 

plot(1, type="n", xaxt="n", xlab="Factor", ylab="Effect on infection rate", xlim=c(0.5,length(x)+0.5), ylim=c(min(Low), max(High)))

abline(a=0, b=0)
rect(x - 0.2, Low, x + 0.2, Mid, col=color)
rect(x - 0.2, Mid, x + 0.2, High, col=color)
axis(1, at=x, labels=rownames(fixed_parameters))
